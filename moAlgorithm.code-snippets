{
	"MO's Algorithm": {
		"prefix": "moAlgorithm",
		"body": [
		  "vector<int> freq;",
		  "int n;",
		  "int BLOCK_SIZE = 450; // This should be sqrt of max value of n",
		  "vector<int> inp;",
		  "int ans = 0;",
		  "struct Query {",
		  "    int l, r, idx;",
		  "    bool operator<(Query other) const",
		  "    {",
		  "        if (l / BLOCK_SIZE != other.l / BLOCK_SIZE) return  l < other.l;",
		  "        return (l / BLOCK_SIZE & 1) ? (r < other.r) : (r > other.r);",
		  "        // Sorts first by block number and then by 'r'",
		  "        // For odd numbered blocks 'r' is in ascending order and for even",
		  "        // 'r' is in decending for optimization purpose",
		  "    }",
		  "};",
		  "",
		  "void add (int index){",
		  "",
		  "// Make the necessary update during addtion of element",
		  "ans += (2*(freq[inp[index]]) + 1)*inp[index];",
		  "freq[inp[index]]++;",
		  "",
		  "}",
		  "",
		  "void remove (int index){",
		  "",
		  "// Make the necessary update during removal of element",
		  "ans -= (2*(freq[inp[index]]) - 1)*inp[index];",
		  "freq[inp[index]]--;",
		  "",
		  "",
		  "}",
		  "",
		  "// Offline algorithm, where you try to find answer for the answers to the queries in Block 1 to last Block",
		  "// complexity ((Q + N)*Sqrt(N))",
		  "void MO(int t)",
		  "{",
		  "",
		  "    int q; ",
		  "    cin >> n >> q;",
		  "    inp.resize(n); // resize",
		  "    ans = 0;  // Clear answer",
		  "    for (int i = 0; i < n; i++) cin >> inp[i];",
		  "    int mx = *max_element(inp.begin(),inp.end());",
		  "",
		  "    freq.resize(mx + 1); // resize",
		  "    vector<Query> query;",
		  "    for (int i = 0; i < q; i++)",
		  "    {",
		  "        int x, y;",
		  "        cin >> x >> y;",
		  "        x--;y--;",
		  "        query.push_back({x, y,i});",
		  "",
		  "    }",
		  "    sort(query.begin(),query.end());",
		  "    int l = 0,r = -1;",
		  "    vector<int> result(q);",
		  "    for(auto [nl,nr,i] : query){",
		  "",
		  "        // l tries to go to nl",
		  "        // r tries to go to nr",
		  "",
		  "         while(r > nr) {",
		  "            remove(r);r--;",
		  "        }",
		  "         while(r < nr){",
		  "            r++;add(r);  ",
		  "         } ",
		  "         while(l < nl){",
		  "            remove(l);l++;    ",
		  "         }  ",
		  "         while(l > nl){",
		  "            l--;add(l);",
		  "         } ",
		  "",
		  "         result[i] = ans;",
		  "      ",
		  "    }",
		  "",
		  "    for(int i =0;  i < q ;  i++){",
		  "        cout<<result[i]<<endl;",
		  "    }",
		  "    ",
		  "}",
		  "",
		  ""
		],
		"description": "MO's Algorithm"
	  }
}