{
	"SegmentTree": {
		"prefix": "segtree",
		"body": [
		  "class SegmentTree {",
		  "public : ",
		  "        vector<int> segtree;",
		  "        SegmentTree(int n){",
		  "             segtree.resize(4*(n + 2));",
		  "        }",
		  "",
		  "        void build(vector<int> &inp,int index, int low, int high){",
		  "        ",
		  "        if(high == low){",
		  "            segtree[index] = inp[high];",
		  "            return;",
		  "        } ",
		  "            int mid = low + (high-low)/2;",
		  "            build(inp, 2*index + 1, low, mid);",
		  "            build(inp, 2*index + 2, mid + 1, high);",
		  "            //Modify 1",
		  "            segtree[index] = ${1: segtree[2*index +1] + segtree[2*index + 2]} ;",
		  "            return;",
		  "        }",
		  "",
		  "        void update(int index, int low, int high, int k, int val){",
		  "            ",
		  "            // Update the value of index k to 'val'",
		  "            int mid = low + (high -low)/2;",
		  "            if(high == low){",
		  "                segtree[index] = val;",
		  "                return;",
		  "            } ",
		  "            if(k <= mid) update(2*index + 1, low, mid, k , val);",
		  "            else update(2*index + 2,mid +1, high, k , val);",
		  "            //Modify 2",
		  "            segtree[index] = ${2:segtree[2*index +1] + segtree[2*index + 2]} ;",
		  "            return;",
		  "",
		  "        }",
		  "",
		  "        int query(int index, int low, int high, int l, int r){",
		  "",
		  "            // Modify 3",
		  "            if(l> high || low> r) return ${3:0}; // No overlap",
		  "            if(l<=low && r>=high) return segtree[index]; // Complete overlap ",
		  "            int mid = low + (high -low)/2;",
		  "            int left = query(2*index + 1, low, mid, l, r);",
		  "            int right = query(2*index + 2, mid + 1, high, l,r);",
		  "            // Modify 4",
		  "            return  ${4:left + right};",
		  "        }",
		  "",
		  "};",
		  "",
		  "// SegmentTree segtree1(n)  ; n = size of the 'inp' vector",
		  "// segtree1.build(inp,0,0,n-1) -> first build it and then use",
		  "// 0 based indexing has been used, that's why high = n-1 (initially);",
		  "// For printing the segtree us dbg(segtree1.segtree) "

		],
		"description": "SegmentTree"
	  }
}