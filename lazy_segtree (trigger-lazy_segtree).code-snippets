{

"Lazy_segment_tree": {
  "prefix": "lazy_segtree",
  "body": [
    "class LazySegmentTree {",
    "public : ",
    "        int n;",
    "        vector<int> segtree, lazy;",
    "        LazySegmentTree(int _n){",
    "             n = _n;",
    "             segtree.resize(4*(n + 2));",
    "             lazy.resize(4*(n + 2));",
    "        }",
    "        void build(vector<int> &inp){ buildHelper(inp, 0, 0, n - 1);};",
    "        void update(int l, int r, int val){ updateHelper(0,0,n-1,l,r,val);};",
    "        int query(int l, int r) {return queryHelper(0,0,n-1,l,r);};",
    " ",
    "        int merge(int left, int right){",
    "          // Modify 1",
    "          return (left + right);",
    "        }",
    " ",
    "        void push(int index, int low, int high){",
    " ",
    "            if(lazy[index] != 0 ){",
    " ",
    "                // Modify 2",
    "                segtree[index] += (high - low + 1)*lazy[index];",
    "                if(low != high){",
    "                    lazy[2*index + 1] += lazy[index];",
    "                    lazy[2*index + 2] += lazy[index]; ",
    "                }",
    "                lazy[index] = 0;",
    "            }",
    "        }",
    "      ",
    "        void buildHelper(vector<int> &inp,int index , int low , int high){",
    "        ",
    "        if(high == low){",
    "            segtree[index] = inp[high];",
    "            return;",
    "        } ",
    "            int mid = low + (high-low)/2;",
    "            buildHelper(inp, 2*index + 1, low, mid);",
    "            buildHelper(inp, 2*index + 2, mid + 1, high);",
    "            segtree[index] =  merge(segtree[2*index +1],segtree[2*index + 2]);",
    "            return;",
    "        }",
    " ",
    "        void updateHelper(int index, int low, int high, int l, int r, int val){",
    " ",
    "            // Increase the all the values in the range [l,r] by val",
    " ",
    "            push(index,low,high);",
    "            if(r < low || l > high) return;",
    "           ",
    "            if(low >= l && high<= r){",
    "                // Modify 3",
    "                lazy[index] += val;",
    "                push(index,low,high);",
    "                return;",
    "            }",
    "            ",
    "            int mid = low + (high -low)/2;",
    " ",
    "            updateHelper(2*index + 1, low, mid, l, r , val);",
    "            updateHelper(2*index + 2,mid +1, high, l,r , val);",
    "            segtree[index] = merge(segtree[2*index +1],segtree[2*index + 2]);",
    "            return;",
    " ",
    "        }",
    " ",
    "        int queryHelper(int index, int low, int high, int l, int r){",
    " ",
    "            ",
    "            push(index,low,high);",
    "            ",
    "            // Modify 4",
    "            if(r < low || l > high) return 0;",
    " ",
    "            if(low >= l && high<= r) return segtree[index];",
    "            int mid = low + (high -low)/2;",
    "            int left = queryHelper(2*index + 1, low, mid, l, r);",
    "            int right = queryHelper(2*index + 2, mid + 1, high, l,r);",
    "            return  merge(left,right);",
    "        }",
    " ",
    "};",
    " ",
    "// LazySegmentTree sg(n)  ; n = size of the 'inp' vector",
    "// sg.build(inp) -> first build it and then use",
    "// 0 based indexing has been used",
    "// sg.update(l,r,val); ",
    "// sg.query(l,r);",
    "// For printing the segtree us dbg(sg.segtree)"
  ],
  "description": "Lazy_segment_tree"
}


}
