
{
"SegmentTree": {
	"prefix": "segtree",
	"body": [
	  "class SegmentTree {",
	  "public : ",
	  "        int n;",
	  "        vector<int> segtree;",
	  "        SegmentTree(int _n){",
	  "             n = _n;",
	  "             segtree.resize(4*(n + 2));",
	  "        }",
	  "        void build(vector<int> &inp){ buildHelper(inp, 0, 0, n - 1);};",
	  "        void update(int k, int val){ updateHelper(0,0,n-1,k,val);};",
	  "        int query(int l, int r) {return queryHelper(0,0,n-1,l,r);};",
	  "",
	  "        int merge(int left, int right){",
	  "          return ${1:(left + right)};",
	  "        }",
	  "      ",
	  "        void buildHelper(vector<int> &inp,int index , int low , int high){",
	  "        ",
	  "        if(high == low){",
	  "            segtree[index] = inp[high];",
	  "            return;",
	  "        } ",
	  "            int mid = low + (high-low)/2;",
	  "            buildHelper(inp, 2*index + 1, low, mid);",
	  "            buildHelper(inp, 2*index + 2, mid + 1, high);",
	  "            segtree[index] =  merge(segtree[2*index +1],segtree[2*index + 2]);",
	  "            return;",
	  "        }",
	  "",
	  "        void updateHelper(int index, int low, int high, int k, int val){",
	  "            ",
	  "            // Update the value of index k to 'val'",
	  "            int mid = low + (high -low)/2;",
	  "            if(high == low){",
	  "                segtree[index] = val;",
	  "                return;",
	  "            } ",
	  "            if(k <= mid) updateHelper(2*index + 1, low, mid, k , val);",
	  "            else updateHelper(2*index + 2,mid +1, high, k , val);",
	  "            segtree[index] = merge(segtree[2*index +1],segtree[2*index + 2]) ;",
	  "            return;",
	  "",
	  "        }",
	  "",
	  "        int queryHelper(int index, int low, int high, int l, int r){",
	  "",
	  "            // Modify 1",
	  "            if(l> high || low> r) return  ${2: 0}; // No overlap",
	  "            if(l<=low && r>=high) return segtree[index]; // Complete overlap ",
	  "            int mid = low + (high -low)/2;",
	  "            int left = queryHelper(2*index + 1, low, mid, l, r);",
	  "            int right = queryHelper(2*index + 2, mid + 1, high, l,r);",
	  "            return  merge(left,right);",
	  "        }",
	  "",
	  "};",
	  "",
	  "// SegmentTree sg(n)  ; n = size of the 'inp' vector",
	  "// sg.build(inp) -> first build it and then use",
	  "// 0 based indexing has been used",
	  "// sg.update(index, val);",
	  "// sg.query(l,r);",
	  "// For printing the segtree us dbg(sg.segtree) "
	],
	"description": "SegmentTree"
  }
}
