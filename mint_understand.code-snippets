{
"mint_understand": {
  "prefix": "mint_understand",
  "body": [
    "template <int MODULO>",
    "",
    "struct ModularInt {",
    "",
    "    int value;",
    "",
    "    // Constructor if int is given",
    "    ModularInt(int llvalue) : value(llvalue % MODULO)",
    "    {",
    "        if (value < 0) value += MODULO;",
    "    }",
    "",
    "    // Constructor if ModularInt (struct itself) is given",
    "    ModularInt(const ModularInt<MODULO>& other): value(other.value){}",
    "",
    "    // Defaut Constructor",
    "    ModularInt() : value(0){}",
    "",
    "    // Defining += operator, here const is not used because we are changing the value of the object",
    "    // inline is used to make the function faster, it tells the compiler to replace the function call with the actual code so that the function call overhead is reduced ",
    "    // overhead includes the time taken to pass the arguments, return the value, etc.",
    "    // recursive functions can also be made inline, but after some recursion, the complier will not make it inline as inline is not an obligation to the compiler",
    "",
    "    inline void operator+=(ModularInt<MODULO> other)",
    "    {",
    "        value += other.value;",
    "        if (value >= MODULO)",
    "            value -= MODULO;",
    "    }",
    "",
    "    // Defining - operator, here const is used because we are not changing the value of the object",
    "    inline ModularInt<MODULO> operator+(ModularInt<MODULO> other) const",
    "    {",
    "        return ModularInt<MODULO>(value + other.value >= MODULO ? value + other.value - MODULO : value + other.value);",
    "    }",
    "    ",
    "    // -= operator",
    "    inline void operator-=(ModularInt<MODULO> other)",
    "    {",
    "        value -= other.value;",
    "        if (value < 0) value += MODULO;",
    "    }",
    "    ",
    "    // - operator",
    "    inline ModularInt<MODULO> operator-(ModularInt<MODULO> other) const",
    "    {",
    "        return ModularInt<MODULO>(value - other.value < 0 ? value - other.value + MODULO : value - other.value);",
    "    }",
    "",
    "    // negation operator, example -a: it is equivalent to 0 - a",
    "    inline ModularInt<MODULO> operator-() const { return ModularInt<MODULO>(value == 0 ? value : MODULO - value); }",
    "",
    "    //  ++operator",
    "    inline ModularInt<MODULO>& operator++()",
    "    {",
    "        ++value;",
    "        if (value == MODULO) {",
    "            value = 0;",
    "        }",
    "        return *this;",
    "    }",
    "",
    "    // operator++",
    "    inline ModularInt<MODULO> operator++(int32_t)",
    "    {",
    "        ModularInt<MODULO> old(*this);",
    "        ++value;",
    "        if (value == MODULO) {",
    "            value = 0;",
    "        }",
    "        return old;",
    "    }",
    "",
    "    // --operator",
    "    inline ModularInt<MODULO>& operator--()",
    "    {",
    "        --value;",
    "        if (value == -1) {",
    "            value = MODULO - 1;",
    "        }",
    "        return *this;",
    "    }",
    "",
    "    // operator--",
    "    inline ModularInt<MODULO> operator--(int32_t)",
    "    {",
    "        ModularInt<MODULO> old(*this);",
    "        --value;",
    "        if (value == -1) {",
    "            value = MODULO - 1;",
    "        }",
    "        return old;",
    "    }",
    "",
    "    // * operator",
    "    inline ModularInt<MODULO> operator*(ModularInt<MODULO> other) const { return ModularInt<MODULO>(1LL * value * other.value); }",
    "",
    "    // *= operator",
    "    inline void operator*=(ModularInt<MODULO> other) { value = 1LL * value * other.value % MODULO; }",
    "    ",
    "    // if we use friend keyword then we can access the private members of the class, and it is not a member function of the struct (it is like we have defined it outside the struct)",
    "    friend ModularInt<MODULO> binpow(ModularInt<MODULO> a, int bll) ",
    "    {",
    "        ",
    "        if (a.value == 0) {",
    "            return ModularInt<MODULO>(bll == 0 ? 1 : 0);",
    "        }",
    "        int b = bll % (MODULO - 1);",
    "        int ans = 1;",
    "        while (b) {",
    "            if (b & 1) {",
    "                ans = 1LL * ans * a.value % MODULO;",
    "            }",
    "            a.value = 1LL * a.value * a.value % MODULO;",
    "            b >>= 1;",
    "        }",
    "        return ModularInt<MODULO>(ans);",
    "    }",
    "",
    "",
    "// Fundae of const function : types of const usage, but here we need only const member function",

    "// const parameter: Ensures the parameter is not modified within the function.",
    "// const member function: Ensures the function does not modify the state of the object.",
    "// const return value: Ensures the return value is not modified by the caller. " ,

    "// here inv is a const function, it means that it will not change the value of the object . So whatever function used inside it should also be const if it is member function",
    "// but in this case binpow is not made as const as it is not a member function of the struct due to freind keyword",
    "// other way to do this is to make binpow as const member function and remove the friend keyword",


    "    inline ModularInt<MODULO> inv() const { return binpow(*this, MODULO - 2); }",
    "",
    "    // / operator",
    "    inline ModularInt<MODULO> operator/(ModularInt<MODULO> other) const { return (*this) * other.inv(); }",
    "",
    "    // /= operator",
    "    inline void operator/=(ModularInt<MODULO> other) { value = 1LL * value * other.inv().value % MODULO; }",
    "",
    "    // all the comparison operators",
    "    inline bool operator==(ModularInt<MODULO> other) const { return value == other.value; }",
    "    inline bool operator!=(ModularInt<MODULO> other) const { return value != other.value; }",
    "    inline bool operator>(ModularInt<MODULO> other) const { return value > other.value; }",
    "    inline bool operator<(ModularInt<MODULO> other) const { return value < other.value; }",
    "    inline bool operator<=(ModularInt<MODULO> other) const { return value <= other.value; }",
    "    inline bool operator>=(ModularInt<MODULO> other) const { return value >= other.value; }",
    "",
    "    // this allows us to convert the struct to int or bool. Ex : mint x = 5; int a = (int)x;",
    "    explicit operator int() const { return value; }",
    "    explicit operator bool() const { return value; }",
    "",
    "    // input and output functions",
    "    friend istream& operator>>(istream& inp, ModularInt<MODULO>& mint)",
    "    {",
    "        inp >> mint.value;",
    "        return inp;",
    "    }",
    "    friend ostream& operator<<(ostream& out, const ModularInt<MODULO>& mint)",
    "    {",
    "        out << mint.value;",
    "        return out;",
    "    }",
    "};",
    "",
    "// mint a = 5; int b = 6; a/b will work as 'b' gets implicitly converted to mint",
    "// but b/a will not work as operator befroe '/' must be of mint type in way we have defined",
    "",
    "const int MOD = 1000000007;",
    "",
    "typedef ModularInt<MOD> mint;",
    "vector<mint> fact(1, 1);",
    "vector<mint> inv_fact(1, 1);",
    "",
    "mint C(int n, int k)",
    "{",
    "    if (k < 0 || k > n) {",
    "        return 0;",
    "    }",
    "    mint t = 1;",
    "",
    "    while ( fact.size() < n + 1) {",
    "        fact.push_back(fact.back() * fact.size());",
    "        inv_fact.push_back(t / fact.back());",
    "    }",
    "    return fact[n] * inv_fact[k] * inv_fact[n - k];",
    "}"
  ],
  "description": "mint_understand"
}
}