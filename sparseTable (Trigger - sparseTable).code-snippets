{
	"SparseTable": {
		"prefix": "sparseTable",
		"body": [
		  "// build in N logN",
		  "// Query in O(1) -> Only for Idempotent operations like min, max, gcd (A*A = A)",
		  "class SparseTable{",
		  "",
		  "public:",
		  "    int n,LOGN;",
		  "    vector<vector<int>> table;",
		  "",
		  "    int log2_floor(unsigned long long i) {",
		  "        return i ? __builtin_clzll(1) - __builtin_clzll(i) : -1;",
		  "     }",
		  "",
		  "    SparseTable(int _n){",
		  "       n = _n;",
		  "       table.resize(n);",
		  "       LOGN = log2_floor(n) + 3;",
		  "       for(int i =0;  i < n ;  i++) table[i].resize(LOGN + 1);",
		  "    }",
		  "",
		  "    int merge(int a, int b) {",
		  "        return ${1:min(a,b)};",
		  "    }",
		  "",
		  "    void build(vector<int> inp){",
		  "    for(int i = 0; i < n; i++) table[i][0] = inp[i];",
		  "    for(int j = 1; j <= LOGN; j++) {",
		  "        for(int i = 0; i <= n - (1 << j); i++)",
		  "            table[i][j] = merge(table[i][j - 1], table[i + (1 << (j - 1))][j - 1]);",
		  "            // i -------- i + 2^(j-1)-1 --- i + 2^(j-1)------i + 2^j - 1",
		  "            // i --------------------------------------------i + 2^j - 1",
		  "    }",
		  "    }",
		  "",
		  "    //table[i][j] -> min in the range (i) to (i + 2^j - 1)",
		  "",
		  "    int query(int l, int r){",
		  "        int i = log2_floor(r - l + 1);",
		  "        return merge(table[l][i], table[r - (1 << i) + 1][i]);",
		  "            // l -------r - 2^l + 1 -----l + 2^i - 1 ------- r",
		  "    }",
		  "",
		  "};",
		  "",
		  "// 0 based indexing on 'inp' is used",
		  "// SparseTable st(n);",
		  "// st.build(inp);",
		  "// st.query(x,y)"
		],
		"description": "SparseTable"
	  }
}